//
// Created by zmake on 24-12-8.
//
#include "HAL.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <IRsend.h>

static WiFiClient espClient;           // 创建一个客户端
static PubSubClient client(espClient); // 创建一个发布客户端
static IRsend irsend(CONFIG_IRLED_PIN);     // Set the GPIO to be used to sending message

extern HAL::SHT_Info_t sht_info;

static const uint16_t irTestRawLen = 279;
uint16_t irHeatOnArray[irTestRawLen] = {9008, 4480, 550, 554, 572, 528, 572, 1632, 572, 1632, 598, 500, 576, 526, 576, 528,
                                  572, 528, 538, 1664, 576, 528, 570, 1632, 578, 526, 574, 528, 536, 544, 556, 540, 512,
                                  592, 558,
                                  546, 552, 542, 560, 538, 576, 526, 578, 524, 574, 1632, 576, 524, 578, 1626, 576, 526,
                                  602, 498, 576, 524, 582, 504, 580, 1640, 606, 498, 570, 1630, 602, 502, 574, 526, 564,
                                  1640, 576, 524, 630, 20160, 576, 526, 576, 526, 578, 526, 600, 502, 570, 1634, 576,
                                  526, 578, 522, 578, 526, 570, 512, 580, 520, 506, 590, 538, 562, 576, 524, 600, 1606,
                                  540, 560, 602, 500, 604, 498, 602, 500, 602, 498, 574, 512, 646, 498, 604, 498, 538,
                                  546, 552, 546, 510, 588, 594, 504, 600, 502, 598, 506, 572, 528, 596, 1608, 596, 1612,
                                  510, 1716, 622, 40430, 9126, 4472, 568, 534, 568, 534, 568, 1636, 568, 1640, 534, 564,
                                  568, 534, 568, 534, 568, 534, 566, 1638, 568, 534, 564, 1638, 568, 534, 564, 536, 536,
                                  546, 552, 546, 534, 564, 566, 534, 568, 534, 566, 540, 532, 566, 564, 536, 568, 1640,
                                  532, 568, 562, 1644, 556, 540, 538, 564, 566, 536, 566, 536, 564, 1640, 564, 1664,
                                  540, 1664, 534, 544, 534, 566, 566, 1664, 512, 566, 638, 20204, 560, 564, 536, 540,
                                  534, 566, 534, 568, 512, 588, 540, 562, 540, 560, 540, 562, 540, 560, 540, 536, 538,
                                  564, 534, 566, 534, 566, 512, 590, 538, 564, 538, 562, 538, 564, 540, 560, 538, 562,
                                  542, 560, 540, 562, 540, 536, 536, 566, 534, 566, 534, 568, 510, 590, 538, 566, 536,
                                  566, 538, 1668, 534,
                                  1670, 532, 570, 532, 1672, 532};  // GREE
uint8_t state[8] = {0x0C, 0x05, 0xA0, 0x50, 0x10, 0x20, 0x00, 0xE0};


static uint16_t irHeatOffArray[irTestRawLen] = {8938, 4548, 602, 500, 600, 500, 572, 1632, 602, 498, 570, 534, 604, 496,
                                                652, 486, 576,
                                                522, 528, 1696, 570, 512, 552, 1670, 572, 512, 578, 522, 510, 586, 576,
                                                526, 600, 502,
                                                576, 526, 576, 524, 600, 502, 576, 526, 600, 502, 564, 1640, 600, 500,
                                                578, 524, 574,
                                                530, 558, 520, 554, 546, 562, 536, 598, 1612, 508, 588, 512, 1698, 554,
                                                546, 508, 590,
                                                564, 1646, 526, 570, 676, 20136, 602, 500, 600, 500, 600, 502, 602, 484,
                                                580, 520, 552,
                                                546, 538, 564, 538, 560, 566, 534, 598, 504, 600, 500, 602, 500, 602,
                                                500, 568, 1636,
                                                600, 504, 596, 488, 578, 544, 560, 518, 580, 518, 558, 540, 540,
                                                558, 602, 500, 602, 500, 600, 502, 598, 504, 568, 534, 560, 522, 508,
                                                590, 538, 1668,
                                                552, 546, 536, 1672, 554, 546, 644, 40430, 9090, 4504, 568, 532, 568,
                                                534, 536, 1668,
                                                568, 534, 538, 544, 580, 524, 550, 544, 534, 566, 568, 1642, 528, 568,
                                                538, 1670, 556,
                                                544, 556, 546, 532, 568, 534, 566, 566, 534, 568, 534, 568, 534, 562,
                                                540, 560, 538,
                                                536, 546, 530, 1694, 534, 548, 528, 568, 564, 538, 566, 536, 564, 536,
                                                568, 534, 568,
                                                1638, 564, 1640, 564, 1646, 532, 564, 564, 538, 564, 1662, 534, 552,
                                                662, 20194, 540,
                                                540, 562, 540, 562, 538, 564, 536, 534, 550, 552, 552, 550, 546, 532,
                                                568, 562, 538,
                                                562, 542,
                                                560, 562, 542, 538, 562, 538, 558, 542, 536, 566, 534, 566, 538, 562,
                                                540, 564, 536,
                                                566, 536, 562, 538, 538, 560, 544, 532, 568, 532, 566, 538, 564, 536,
                                                566, 536, 564,
                                                538, 566, 536, 1666, 538, 1668,
                                                536, 566, 534, 566, 536};  // GREE



static void mqtt_callback(char *topic, byte *payload, unsigned int length) {
    Serial.print("Message arrived [");
    Serial.print(topic);
    Serial.print("] ");
    for (int i = 0; i < length; i++) {
        Serial.print((char) payload[i]);
    }
    Serial.println();
    //处理接收到的消息
    //判断消息内容控制灯的开关，如果是on则打开，如果是off则关闭
    if ((char) payload[0] == 'o' && (char) payload[1] == 'n') {
        // TODO:控制灯开
        // irsend.sendNEC(0xFF38C7, 32);
//        irsend.sendGree(0x0C05A050102000E0, 64, 1);
        irsend.sendRaw(irHeatOnArray, irTestRawLen, 38);
    } else if ((char) payload[0] == 'o' && (char) payload[1] == 'f' && (char) payload[2] == 'f') {
        // TODO:控制灯关
        irsend.sendRaw(irHeatOffArray, irTestRawLen, 38);
    }
}

static void mqtt_report(void) {
    char msg[50];
    sprintf(msg, R"({"temperature":%f,"humidity":%f})", sht_info.temp, sht_info.humi);
    client.publish(CONFIG_MQTT_PUB_TOPIC, msg);
}

static void mqtt_report_task(void *pvParameters) {
    while (1) {
        vTaskDelay(1000 * 5 / portTICK_PERIOD_MS);
        if (client.connected()) {
            mqtt_report();
        }
    }
}


void HAL::MQTT_Init() {

    client.setServer(CONFIG_MQTT_SERVER, CONFIG_MQTT_PORT); //设置客户端连接的服务器,连接Onenet服务器

    client.connect(CONFIG_MQTT_DEVICE_ID); //客户端连接到指定的产品的指定设备.同时输入鉴权信息
    if (client.connected()) {
        Serial.println("MQTT Server is connected!"); //判断一下是不是连好了.
    }
    client.subscribe(CONFIG_MQTT_SUB_TOPIC); //订阅主题
    client.setCallback(mqtt_callback); //设置回调函数
    irsend.begin();
    xTaskCreate(mqtt_report_task, "mqtt_report_task", 4096, NULL, 5, NULL);
}

void HAL::MQTT_Update() {
    client.loop(); //保持连接
}